---
id: built-in-types
author: Ryan
title: 3.Go内置类型
date: 2024-9-23
categories: Go
tags: [Go]
---

## 1 内置类型
### 1.1 数值类型
####  整数类型  
+ `int8`：8 位有符号整数，范围：-128 到 127
+ `int16`：16 位有符号整数，范围：-32768 到 32767
+ `int32`：32 位有符号整数，范围：-2147483648 到 2147483647
+ `int64`：64 位有符号整数，范围：-9223372036854775808 到 9223372036854775807
+ `int`：根据平台选择 32 位或 64 位有符号整数



#### 无符号整数
+ `uint8`：8 位无符号整数，范围：0 到 255
+ `uint16`：16 位无符号整数，范围：0 到 65535
+ `uint32`：32 位无符号整数，范围：0 到 4294967295
+ `uint64`：64 位无符号整数，范围：0 到 18446744073709551615
+ `uint`：根据平台选择 32 位或 64 位无符号整数



####  浮点数类型  
+ `float32`：32 位浮点数
+ `float64`：64 位浮点数（Go 中的默认浮点数类型）



#### 复数类型
+ `complex64`：实部和虚部为 `float32`
+ `complex128`：实部和虚部为 `float64`（Go 中的默认复数类型）



#### 其他数值类型
+ `byte`：`uint8` 的别名，常用于表示单个字节
+ `rune`：`int32` 的别名，常用于表示 Unicode 码点



### 1.2 布尔类型
 取值：`true` 或 `false`

一个简单的例子：var b bool = true。

### **1.3 字符串类型** (`string`)
+ 表示一串 UTF-8 编码的字符。

### 1.4 派生类型
**派生类型** 是由内置基础类型通过组合或扩展衍生出来的类型。这些派生类型基于已有的基本类型进行复杂数据结构的定义。以下是 Go 语言中常见的派生类型：  

#### **数组类型** (`[N]T`)  
+  数组是一个具有固定长度的同质数据结构，也就是一组具有相同类型 `T` 的元素，长度为 `N`。  
+  数组的长度是其类型的一部分，所以数组的长度不可变。  



#### **切片类型** (`[]T`)  
+ 切片是 Go 语言中用于处理动态数组的一种灵活的数据结构。
+ 切片并不存储具体的数据，而是对底层数组的引用。其长度可以动态变化。



#### **映射类型** (`map[K]V`)  
+ 映射（map）是 Go 中的哈希表结构，用于将键类型 `K` 映射到值类型 `V`。
+ `map` 是引用类型，因此不同的变量可以引用同一个 `map`。



#### **结构体类型** (`struct`)  
+ 结构体是 Go 语言中聚合多个不同类型数据的复合类型。
+ 结构体可以包含多个字段，每个字段可以是不同类型。



#### **指针类型** (`*T`)  
+ 指针类型是指向某种类型 `T` 的内存地址。
+ 在 Go 中，指针不能进行算术运算，但可以通过指针引用来访问或修改变量的值。



#### **函数类型** (`func`)  
+ Go 支持将函数作为一等公民，可以将函数类型赋值给变量或作为参数传递。
+ 函数类型包含参数列表和返回值类型。



#### **接口类型** (`interface`)  
+ 接口是一种抽象类型，定义了一组方法，而不实现这些方法。
+ 任何实现了接口中的所有方法的类型都被认为实现了该接口。



#### **通道类型** (`chan T`)
+ 通道是 Go 中用于 goroutine 之间通信的机制。
+ 可以在通道中发送和接收特定类型 `T` 的数据，通道是并发安全的。



#### **空接口类型** (`interface{}`)
+ 空接口可以表示任何类型，因为所有类型都实现了空接口。
+ 空接口常用于需要存储任意类型的情况。



#### **类型别名**
+ Go 中允许为已有类型定义一个新的名字，称为类型别名。





## 2.内置函数
Go 语言提供了一些常用的 **内置函数**，这些函数在 Go 程序中可以直接使用，而不需要引入任何额外的包。

它们是 Go 语言核心功能的一部分。  

### 1. `len()`
返回字符串、数组、切片、映射、或通道的长度。

示例：

```go
s := "hello"
fmt.Println(len(s))  // 输出: 5
```



### 2. `cap()`
返回数组、切片或通道的容量。

示例：

```go
s := make([]int, 5, 10)
fmt.Println(cap(s))  // 输出: 10
```

### 3. `make()`
用于创建并初始化切片、映射、或通道类型。

示例：

```go
s := make([]int, 0, 5)   // 创建一个容量为 5 的切片
m := make(map[string]int) // 创建一个映射
ch := make(chan int)      // 创建一个整型通道
```



### 4. `new()`
分配内存并返回一个指向类型的指针。返回的是一个零值填充的指针。

示例：

```go
go
复制代码
p := new(int)  // p 是指向 int 类型的指针，默认值为 0
```



### 5. `copy()`
用于将一个切片的数据复制到另一个切片，返回复制的元素个数。

示例：

```go
src := []int{1, 2, 3}
dst := make([]int, 3)
copy(dst, src)
```



### 6. `append()`
向切片的末尾追加元素，并返回扩展后的切片。

示例：

```go
s := []int{1, 2, 3}
s = append(s, 4, 5)  // 追加元素
```



### 7. `delete()`
从映射中删除指定键的键值对。

示例：

```go
m := map[string]int{"a": 1, "b": 2}
delete(m, "a")  // 删除键 "a"
```



### 8. `complex()`
用于创建复数，实部和虚部可以是 `float32` 或 `float64`。

示例：

```go
c := complex(2, 3)  // 创建复数 2 + 3i
```



### 9. `real()`
返回复数的实部。

示例：

```go
c := complex(2, 3)
fmt.Println(real(c))  // 输出: 2
```



### 10. `imag()`
返回复数的虚部。

示例：

```go
c := complex(2, 3)
fmt.Println(imag(c))  // 输出: 3
```



### 11. `close()`
关闭通道，表示不再向通道发送数据。

示例：

```go
ch := make(chan int)
close(ch)  // 关闭通道
```



### 12. `panic()`
导致程序进入恐慌状态，通常在遇到不可恢复的错误时使用。

示例：

```go
panic("an error occurred")  // 引发恐慌
```



### 13. `recover()`
用于恢复程序的执行，从 `panic` 状态中恢复。通常与 `defer` 结合使用。

示例：

```go
defer func() {
    if r := recover(); r != nil {
        fmt.Println("Recovered from panic:", r)
    }
}()
panic("an error occurred")  // 引发并恢复恐慌
```



### 14. `print()` 和 `println()`
用于打印输出，`print()` 和 `println()` 在功能上类似于 `fmt.Print()` 和 `fmt.Println()`，但这些函数主要用于调试目的，不推荐在生产代码中使用。

示例：

```go
print("hello")   // 输出: hello
println("world") // 输出: world
```



### 15. `uintptr()`
将任意指针转换为 `uintptr` 类型（用于低级内存操作）。

示例：

```go
var p *int
uintptrVal := uintptr(unsafe.Pointer(p))  // 将指针转换为 uintptr
```





## 3.基本类型介绍
| 类型 | 长度(字节) | 默认值 | 说明 |
| --- | --- | --- | --- |
| **基础类型** |  |  |  |
| `bool` | 1 | `false` | 布尔值，`true` 或 `false` |
| `int8` | 1 | 0 | 8 位有符号整数，范围：-128 到 127 |
| `int16` | 2 | 0 | 16 位有符号整数，范围：-32768 到 32767 |
| `int32` | 4 | 0 | 32 位有符号整数，范围：-2147483648 到 2147483647 |
| `int64` | 8 | 0 | 64 位有符号整数，范围：-9223372036854775808 到 9223372036854775807 |
| `int` | 平台相关 | 0 | 有符号整数，32 位或 64 位，依赖具体平台 |
| `uint8` | 1 | 0 | 8 位无符号整数，范围：0 到 255 |
| `uint16` | 2 | 0 | 16 位无符号整数，范围：0 到 65535 |
| `uint32` | 4 | 0 | 32 位无符号整数，范围：0 到 4294967295 |
| `uint64` | 8 | 0 | 64 位无符号整数，范围：0 到 18446744073709551615 |
| `uint` | 平台相关 | 0 | 无符号整数，32 位或 64 位，依赖具体平台 |
| `float32` | 4 | 0.0 | 32 位 IEEE-754 浮点数 |
| `float64` | 8 | 0.0 | 64 位 IEEE-754 浮点数（默认浮点数类型） |
| `complex64` | 8 | 0 + 0i | 实部和虚部均为 `float32` 的复数 |
| `complex128` | 16 | 0 + 0i | 实部和虚部均为 `float64` 的复数 |
| `byte` | 1 | 0 | `uint8` 的别名，常用于表示单个字节 |
| `rune` | 4 | 0 | `int32` 的别名，表示 Unicode 码点 |
| `string` | 动态 | "" | UTF-8 编码的字符串，字符串是不可变的 |
| `uintptr` | 平台相关 | 0 | 无符号整型，存储指针，用于底层编程 |
| **派生类型** |  |  |  |
| `array` | 固定长度 | 元素类型的零值 | 定长数组 `[N]T`，长度为编译时确定，元素类型为 `T` |
| `slice` | 动态 | `nil` | 切片 `[]T`，基于数组的动态长度视图，长度和容量可变 |
| `map` | 动态 | `nil` | 映射 `map[K]V`，无序的键值对集合，键为 `K`，值为 `V` |
| `struct` | 动态 | 各字段类型的零值 | 结构体 `struct`，聚合多个字段，每个字段有自己的类型 |
| `pointer` | 8 或 4 | `nil` | 指针 `*T`，指向某个类型 `T` 的地址 |
| `func` | 动态 | `nil` | 函数类型 `func`，定义一组输入参数和返回值 |
| `interface` | 动态 | `nil` | 接口类型 `interface`，定义方法集，由任何实现者实现 |
| `chan` | 动态 | `nil` | 通道 `chan T`，用于 goroutine 之间传递数据 |


**说明：**

1. **基础类型** 包括 Go 语言中内置的原始类型，如整数、浮点数、复数、布尔值和字符串等。
2. **派生类型** 是基于基础类型进一步组合、扩展或引用得出的类型，比如数组、切片、映射、结构体、通道、指针和函数等。
3. **长度(字节)** 列表示数据类型占用的内存大小，某些类型（如切片、映射、通道）在定义时大小不固定，取决于元素或数据的数量。
4. **默认值** 表示未初始化时变量的默认值，`nil` 表示指针类型的零值，而零值是每种类型的默认初始化值。

